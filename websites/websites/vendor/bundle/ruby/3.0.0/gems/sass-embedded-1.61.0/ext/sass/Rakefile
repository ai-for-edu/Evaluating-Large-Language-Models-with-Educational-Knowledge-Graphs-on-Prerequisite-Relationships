# frozen_string_literal: true

require 'rake/clean'

task default: %i[install clean]

task install: %w[embedded.rb] do
  Rake::Task['embedded_sass_pb.rb'].invoke unless File.exist?('embedded_sass_pb.rb')
end

CLEAN.include %w[protoc.exe *.proto *.tar.gz *.zip]

CLOBBER.include %w[sass_embedded embedded.rb embedded_sass_pb.rb]

file 'protoc.exe' do |t|
  fetch(ENV.fetch('PROTOC_BIN') { Configuration.default_protoc }, t.name)
  chmod 'a+x', t.name
end

file 'sass_embedded' do |t|
  archive = fetch(ENV.fetch(t.name.upcase) { Configuration.default_sass_embedded })
  unarchive archive
  rm archive

  if ENV.key?('NIX_BINTOOLS')
    sh 'patchelf',
       '--set-interpreter', File.read("#{ENV.fetch('NIX_BINTOOLS')}/nix-support/dynamic-linker").chomp,
       (['sass_embedded/src/dart', 'sass_embedded/dart-sass-embedded'].find { |exe| File.exist?(exe) })
  end
end

file 'embedded.rb' => %w[sass_embedded] do |t|
  exe = 'sass_embedded/dart-sass-embedded'
  exe = "#{exe}#{['', '.bat', '.exe'].find { |ext| File.exist?("#{exe}#{ext}") }}"

  raise "#{exe} not found" unless File.exist?(exe)

  runtime = 'sass_embedded/src/dart'
  runtime = "#{runtime}#{['', '.exe'].find { |ext| File.exist?("#{runtime}#{ext}") }}"
  snapshot = 'sass_embedded/src/dart-sass-embedded.snapshot'

  command = if File.exist?(runtime) && File.exist?(snapshot)
              "
        File.absolute_path('#{runtime}', __dir__),
        File.absolute_path('#{snapshot}', __dir__)
      "
            else
              "
        File.absolute_path('#{exe}', __dir__)
      "
            end

  File.write(t.name, <<~EMBEDDED_RB)
    # frozen_string_literal: true

    module Sass
      class Embedded
        class Compiler
          COMMAND = [#{command}].freeze
        end
      end
    end
  EMBEDDED_RB
end

file 'embedded_sass.proto' => %w[embedded.rb] do |t|
  fetch(ENV.fetch('SASS_EMBEDDED_PROTOCOL') { Configuration.default_sass_embedded_protocol }, t.name)
end

rule '_pb.rb' => %w[.proto protoc.exe] do |t|
  sh './protoc.exe', '--proto_path=.', '--ruby_out=.', t.source
end

# This is a FileUtils extension that defines several additional commands to be
# added to the FileUtils utility functions.
module FileUtils
  # PowerShell quirks:
  # - `powershell -Command -`:
  #     Arguments must be part of command, thus cannot pass arguments safely without escaping.
  # - `powershell -Command <script-block> [-args <arg-array>]`:
  #     This only works when invoking powershell subshell in powershell.
  # - `powershell -Command <string> [<CommandParameters>]`:
  #     CommandParameters are joined with command and then parsed, thus cannot pass arguments safely without escaping.
  # - `powershell -File -`:
  #     Arguments must be part of file, thus cannot pass arguments safely without escaping.
  # - `powershell -File <filePath> <args>`:
  #     This is the only way to pass arguments safely without escaping.
  def powershell(file, *args)
    sh 'powershell', '-NoLogo', '-NoProfile', '-NonInteractive', '-ExecutionPolicy', 'Bypass', '-File', file, *args
  end

  def junzip(archive, dest = '.')
    require 'java'

    Rake.rake_output_message "Archive:  #{archive}" if Rake::FileUtilsExt.verbose_flag

    current_directory = java.nio.file.Paths.get(org.jruby.Ruby.getGlobalRuntime.getCurrentDirectory)
    zip_file = java.util.zip.ZipFile.new(current_directory.resolve(archive).toFile)
    dest_path = current_directory.resolve(dest).normalize
    entries = zip_file.entries
    while entries.hasMoreElements
      entry = entries.nextElement
      name = entry.getName
      path = dest_path.resolve(name).normalize
      raise unless path.startsWith(dest_path)

      Rake.rake_output_message "  inflating: #{name}" if Rake::FileUtilsExt.verbose_flag

      if entry.isDirectory
        java.nio.file.Files.createDirectories(path)
      else
        java.nio.file.Files.createDirectories(path.getParent)
        java.nio.file.Files.copy(zip_file.getInputStream(entry), path)
      end
    end
  ensure
    zip_file&.close
  end

  def unarchive(archive, dest = '.')
    case archive.downcase
    when ->(name) { name.include?('.tar.') || name.end_with?('.tar') }
      mkdir_p dest
      sh 'tar', '-vxC', dest, '-f', archive, '--no-same-owner', '--no-same-permissions'
    when ->(name) { name.end_with?('.zip') }
      if RUBY_PLATFORM == 'java'
        junzip archive, dest
      elsif Gem.win_platform?
        powershell 'expand-archive.ps1', '-Force', '-LiteralPath', archive, '-DestinationPath', dest
      else
        sh 'unzip', '-od', dest, archive
      end
    else
      raise ArgumentError, "Unknown archive format #{archive}"
    end
  end

  def fetch(source_uri, dest_path = nil)
    require 'rubygems/remote_fetcher'

    unless source_uri.is_a?(URI::Generic)
      begin
        source_uri = URI.parse(source_uri)
      rescue StandardError
        source_uri = URI.parse(URI::DEFAULT_PARSER.escape(source_uri.to_s))
      end
    end

    scheme = source_uri.scheme
    source_path = URI::DEFAULT_PARSER.unescape(source_uri.path || source_uri.opaque)

    if Gem.win_platform? && scheme =~ /^[a-z]$/i && !source_path.include?(':')
      source_path = "#{scheme}:#{source_path}"
      scheme = nil
    end

    dest_path = File.basename(source_path) if dest_path.nil?

    case scheme
    when nil, 'file'
      if Gem.win_platform? && source_path[0].chr == '/' && source_path[1].chr =~ /[a-z]/i && source_path[2].chr == ':'
        source_path = source_path[1..]
      end
      cp source_path, dest_path
    else
      fetcher = Gem::RemoteFetcher.fetcher
      symbol = "fetch_#{scheme}".to_sym
      raise ArgumentError, "Unsupported URI scheme #{scheme}" unless fetcher.respond_to?(symbol)

      if Rake::FileUtilsExt.verbose_flag
        redacted_uri = Gem::RemoteFetcher::FetchError.new('', source_uri).uri
        Rake.rake_output_message "fetch #{redacted_uri}"
      end

      unless Rake::FileUtilsExt.nowrite_flag
        data = fetcher.public_send(symbol, source_uri)
        Gem.write_binary(dest_path, data)
      end
    end

    dest_path
  end
end

# The {Configuration} module.
module Configuration
  module Platform
    OS = case RbConfig::CONFIG['host_os'].downcase
         when /darwin/
           'darwin'
         when /linux-android/
           'linux-android'
         when /linux-musl/
           'linux-musl'
         when /linux-uclibc/
           'linux-uclibc'
         when /linux/
           'linux'
         when *Gem::WIN_PATTERNS
           'windows'
         else
           RbConfig::CONFIG['host_os'].downcase
         end

    CPU = case RbConfig::CONFIG['host_cpu'].downcase
          when /amd64|x86_64|x64/
            'x86_64'
          when /i\d86|x86|i86pc/
            'i386'
          when /arm64|aarch64/
            'aarch64'
          when /arm/
            # Ruby before 3.0 reports "arm" instead of "arm64" as host_cpu on darwin
            OS == 'darwin' ? 'aarch64' : 'arm'
          when /ppc64le|powerpc64le/
            'powerpc64le'
          when /s390x/
            's390x'
          else
            RbConfig::CONFIG['host_cpu']
          end

    ARCH = "#{CPU}-#{OS}"
  end

  private_constant :Platform

  module_function

  def default_sass_embedded
    require 'json'

    repo = 'https://github.com/sass/dart-sass-embedded'

    spec = JSON.parse(File.read(File.absolute_path('package.json', __dir__)))

    tag_name = spec['dependencies']['sass-embedded']

    message = "sass_embedded for #{Platform::ARCH} not available at #{repo}/releases/tag/#{tag_name}"

    os = case Platform::OS
         when 'darwin'
           'macos'
         when 'linux'
           'linux'
         when 'linux-android'
           repo = 'https://github.com/dart-android/dart-sass-embedded'
           'android'
         when 'linux-musl'
           repo = 'https://github.com/dart-musl/dart-sass-embedded'
           'linux'
         when 'windows'
           'windows'
         else
           raise NotImplementedError, message
         end

    cpu = case Platform::CPU
          when 'i386'
            'ia32'
          when 'x86_64'
            'x64'
          when 'aarch64'
            'arm64'
          when 'arm'
            'arm'
          else
            raise NotImplementedError, message
          end

    ext = Platform::OS == 'windows' ? 'zip' : 'tar.gz'

    "#{repo}/releases/download/#{tag_name}/sass_embedded-#{tag_name}-#{os}-#{cpu}.#{ext}"
  end

  def default_protoc
    repo = 'https://repo.maven.apache.org/maven2/com/google/protobuf/protoc'

    version = Gem::Dependency.new('google-protobuf').to_spec.version

    message = "protoc for #{Platform::ARCH} not available at #{repo}/#{version}"

    os = case Platform::OS
         when 'darwin'
           'osx'
         when 'linux'
           'linux'
         when 'windows'
           'windows'
         else
           raise NotImplementedError, message
         end

    cpu = case Platform::CPU
          when 'i386'
            'x86_32'
          when 'x86_64'
            'x86_64'
          when 'aarch64'
            'aarch_64'
          when 'powerpc64le'
            'ppcle_64'
          when 's390x'
            's390_64'
          else
            raise NotImplementedError, message
          end

    "#{repo}/#{version}/protoc-#{version}-#{os}-#{cpu}.exe"
  end

  def default_sass_embedded_protocol
    require 'json'
    require 'open3'
    require_relative 'embedded'

    stdout, stderr, status = Open3.capture3(*Sass::Embedded::Compiler::COMMAND, '--version')

    raise stderr unless status.success?

    tag_name = JSON.parse(stdout)['protocolVersion']

    "https://github.com/sass/embedded-protocol/raw/#{tag_name}/embedded_sass.proto"
  end
end
