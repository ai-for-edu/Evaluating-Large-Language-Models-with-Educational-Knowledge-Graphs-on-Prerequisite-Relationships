<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d1" for="node" attr.name="description" attr.type="string" />
  <key id="d0" for="node" attr.name="name" attr.type="string" />
  <graph edgedefault="directed">
    <node id="54">
      <data key="d0">Subclass</data>
      <data key="d1">A subclass is a class derived from the superclass. It inherits the properties of the superclass and also contains attributes of its own.</data>
    </node>
    <node id="53">
      <data key="d0">Enhanced Entity-Relationship</data>
      <data key="d1">Enhanced entity-relationship diagrams are advanced database diagrams very similar to regular ER diagrams which represent requirements and complexities of complex databases.  It is a diagrammatic technique for displaying the Sub Class and Super Class; Specialization and Generalization; Union or Category; Aggregation. </data>
    </node>
    <node id="56">
      <data key="d0">Data Model</data>
      <data key="d1">Data Models are fundamental entities to introduce abstraction in a DBMS. Data models define how data is connected to each other and how they are processed and stored inside the system.</data>
    </node>
    <node id="48">
      <data key="d0">Entity</data>
      <data key="d1">An entity is a real-world thing that can be distinctly identified as a person, place, or concept. It is an object which is distinguishable from others.</data>
    </node>
    <node id="59">
      <data key="d0">Many-To-Many</data>
      <data key="d1"> a many-to-many relationship where many occurrences in an entity relate to many occurrences in another entity.</data>
    </node>
    <node id="57">
      <data key="d0">Cardinality ratios</data>
      <data key="d1">Specifies the maximum number of relationships that an entity can participate in.</data>
    </node>
    <node id="96">
      <data key="d0">Two-Phase Locking (2PL) Protocol</data>
      <data key="d1">Two-Phase Locking Protocol is also known as 2PL protocol is a method of concurrency control in DBMS that ensures serializability by applying a lock to the transaction data which blocks other transactions to access the same data simultaneously. Two-Phase Locking protocol helps to eliminate the concurrency problem in DBMS.</data>
    </node>
    <node id="94">
      <data key="d0">Locking</data>
      <data key="d1">Locking protocols are used in database management systems as a means of concurrency control. Multiple transactions may request a lock on a data item simultaneously.</data>
    </node>
    <node id="15">
      <data key="d0">Domain</data>
      <data key="d1">Domains are the sets of all possible values for attributes.</data>
    </node>
    <node id="14">
      <data key="d0">Relational data model</data>
      <data key="d1">The relational model represents the database as a collection of relations.</data>
    </node>
    <node id="26">
      <data key="d0">ALTER TABLE</data>
      <data key="d1">ALTER TABLE is used to add, delete/drop or modify columns in the existing table. It is also used to add and drop various constraints on the existing table.</data>
    </node>
    <node id="22">
      <data key="d0">DDL</data>
      <data key="d1">A data definition language (DDL) is a computer language used to create and modify the structure of database objects in a database. These database objects include views, schemas, tables, indexes, etc.</data>
    </node>
    <node id="89">
      <data key="d0">Authentication</data>
      <data key="d1">Authentication is the process of confirming that a user logs in only in accordance with the rights to perform the activities he is authorized to perform. User authentication can be performed at the operating system level or database level itself.</data>
    </node>
    <node id="81">
      <data key="d0">Access Control</data>
      <data key="d1">Access control is done by creating user accounts and to control login process by the DBMS. So, that database access of sensitive data is possible only to those people (database users) who are allowed to access such data and to restrict access to unauthorized persons. </data>
    </node>
    <node id="20">
      <data key="d0">Schema</data>
      <data key="d1">A relation schema has a relation name and a list of attributes.</data>
    </node>
    <node id="40">
      <data key="d0">EXCEPT</data>
      <data key="d1">The SQL EXCEPT clause/operator is used to combine two SELECT statements and returns rows from the first SELECT statement that are not returned by the second SELECT statement. This means EXCEPT returns only rows, which are not available in the second SELECT statement</data>
    </node>
    <node id="32">
      <data key="d0">Query</data>
      <data key="d1">A query is a request for data or information from a database table or combination of tables.</data>
    </node>
    <node id="64">
      <data key="d0">Functional dependencies</data>
      <data key="d1">Functional Dependency (FD) is a constraint that determines the relation of one attribute to another attribute in a Database Management System (DBMS).</data>
    </node>
    <node id="67">
      <data key="d0">Implied</data>
      <data key="d1">To design a good database, we need to consider all possible FDs.</data>
    </node>
    <node id="68">
      <data key="d0">Equivalent</data>
      <data key="d1">Two or more than two sets of functional dependencies are called equivalence if the right-hand side of one set of functional dependency can be determined using the second FD set, similarly, the right-hand side of the second FD set can be determined using the first FD set.</data>
    </node>
    <node id="69">
      <data key="d0">Minimal Cover</data>
      <data key="d1">A minimal cover of a set of FDs F is a minimal set of functional dependencies that is equivalent to F.</data>
    </node>
    <node id="99">
      <data key="d0">The Unrepeatable Read Problem</data>
      <data key="d1">The unrepeatable problem occurs when two or more read operations of the same transaction read different values of the same variable.</data>
    </node>
    <node id="95">
      <data key="d0">Concurrent Transactions</data>
      <data key="d1">Concurrent transaction or execution includes multiple transactions which are executed concurrently or simultaneously in the system.</data>
    </node>
    <node id="42">
      <data key="d0">Natural Join</data>
      <data key="d1">A natural join retains all the data of the two tables for only the matched rows, without duplication.</data>
    </node>
    <node id="33">
      <data key="d0">Join</data>
      <data key="d1">When we want to retrieve data from more than one relation, we often need to use join operations.</data>
    </node>
    <node id="102">
      <data key="d0">Read Committed</data>
      <data key="d1">Read Committed is One transaction only sees committed changes by other
transactions.</data>
    </node>
    <node id="93">
      <data key="d0">Isolation</data>
      <data key="d1">In database systems, isolation determines how transaction integrity is visible to other users and systems.</data>
    </node>
    <node id="91">
      <data key="d0">Transactions</data>
      <data key="d1">A transaction is a sequence of database operations grouped together for execution as a logic unit in a DBMS.</data>
    </node>
    <node id="97">
      <data key="d0">Logging</data>
      <data key="d1">Logging is a technique for recovery (assuring atomicity and durability of transactions).</data>
    </node>
    <node id="92">
      <data key="d0">ACID Properties</data>
      <data key="d1">DBMSs ensure the following properties of transactions. Atomicity is the execution of each transaction is atomic, i.e., either all operations are completed or not done at all. Consistency is the states of a database that are consistent (w.r.t. defined business rules) before and after each transaction. Isolation is execution results of each transaction should be unaffected by other concurrently executing transactions. Durability is once a transaction has been successfully completed, its effects should persist in the database</data>
    </node>
    <node id="98">
      <data key="d0">The Dirty Read Problem</data>
      <data key="d1">Dirty read is a read of uncommitted data. If a particular row is modified by another running application and not yet committed, we also run an application to read the same row with the same uncommitted data.</data>
    </node>
    <node id="55">
      <data key="d0">Superclass</data>
      <data key="d1">This type of relationship between subclass and superclass is often described as an ISA relationship type.</data>
    </node>
    <node id="80">
      <data key="d0">Database Security</data>
      <data key="d1">Database security refers to the collective measures used to protect and secure a database or database management software from illegitimate use and malicious cyber threats and attacks.</data>
    </node>
    <node id="85">
      <data key="d0">SQL Injection</data>
      <data key="d1">SQL injection attacks from internal and external users</data>
    </node>
    <node id="50">
      <data key="d0">Data integrity</data>
      <data key="d1">Data integrity refers to the accuracy and consistency of data stored in a database or a data warehouse. Data with “integrity” is said to have a complete structure, i.e. all characteristics defining the data must be correct.</data>
    </node>
    <node id="88">
      <data key="d0">Role-Based Access Control (RBAC)</data>
      <data key="d1">Access rights are grouped by roles, and the use of resources is restricted to individuals assigned to specific roles.
</data>
    </node>
    <node id="103">
      <data key="d0">Serializable</data>
      <data key="d1">Serializable is the highest solution level. All transactions are totally isolated from other transactions. It is safe but may cause significant performance hit.</data>
    </node>
    <node id="19">
      <data key="d0">Foreign key</data>
      <data key="d1">A foreign key is a column or group of columns in a relational database table that provides a link between data in two tables.</data>
    </node>
    <node id="21">
      <data key="d0">SQL</data>
      <data key="d1">SQL stands for Structured Query Language.  It is used for storing and managing data in a relational database management system (RDMS).</data>
    </node>
    <node id="27">
      <data key="d0">Candidate key</data>
      <data key="d1">A candidate key is a combination of attributes that can be uniquely used to identify a database record without referring to any other data.</data>
    </node>
    <node id="28">
      <data key="d0">DML</data>
      <data key="d1">A data manipulation language (DML) is a computer programming language used for adding (inserting), deleting, and modifying (updating) data in a database. A DML is often a sublanguage of a broader database language such as SQL, with the DML comprising some of the operators in the language.</data>
    </node>
    <node id="34">
      <data key="d0">Primary Key</data>
      <data key="d1">A primary key is a special relational database table column (or combination of columns) designated to uniquely identify all table records.</data>
    </node>
    <node id="23">
      <data key="d0">Data type</data>
      <data key="d1">Data Types define the type of value that can be stored in a table column.</data>
    </node>
    <node id="35">
      <data key="d0">SELECT DISTINCT</data>
      <data key="d1">The SELECT DISTINCT statement is used to return only distinct (different) values. Inside a table, a column often contains many duplicate values; and sometimes you only want to list the different (distinct) values.</data>
    </node>
    <node id="29">
      <data key="d0">SELECT</data>
      <data key="d1">SQL provides the SELECT statement for retrieving data from a database</data>
    </node>
    <node id="30">
      <data key="d0">INSERT</data>
      <data key="d1">The INSERT statement is used to add tuples into a relation.</data>
    </node>
    <node id="31">
      <data key="d0">DELETE</data>
      <data key="d1">The DELETE statement is used to remove tuples from a relation.</data>
    </node>
    <node id="101">
      <data key="d0">Read Uncommitted</data>
      <data key="d1">Read Uncommitted is the least restrictive isolation level.</data>
    </node>
    <node id="52">
      <data key="d0">Key attributes</data>
      <data key="d1">A key attribute is the unique characteristic of the entity.</data>
    </node>
    <node id="77">
      <data key="d0">Projection</data>
      <data key="d1">choose certain attributes (i.e., columns).</data>
    </node>
    <node id="76">
      <data key="d0">Relational Algebra</data>
      <data key="d1">Relational algebra (RA) provides an intermediate step for evaluating SQL.</data>
    </node>
    <node id="45">
      <data key="d0">Entity-Relationship Model</data>
      <data key="d1">An Entity–relationship model (ER model) describes the structure of a database with the help of a diagram, which is known as Entity Relationship Diagram (ER Diagram). An ER model is a design or blueprint of a database that can later be implemented as a database. </data>
    </node>
    <node id="51">
      <data key="d0">weak entity </data>
      <data key="d1">A weak entity type is an entity type that does not have sufficient attributes
to form a primary key.</data>
    </node>
    <node id="84">
      <data key="d0">Mandatory Access Control (MAC)</data>
      <data key="d1">Restrict access to objects based on the sensitivity of the information contained in the objects and the formal authorization of subjects to access information of such sensitivity.</data>
    </node>
    <node id="12">
      <data key="d0">Subset</data>
      <data key="d1">If A and B are two sets, and every element of set A is also an element of set B, then A is called a subset of B</data>
    </node>
    <node id="4">
      <data key="d0">Set</data>
      <data key="d1">In mathematics, a set is nothing more than a collection of objects. Similarly, in databases, records within a table can be treated as objects in a set - i.e. the table becomes a set of records. The SET operator allows the tables of a database to be treated as objects in a set when performing a query.</data>
    </node>
    <node id="90">
      <data key="d0">Trojan Horse attacks</data>
      <data key="d1">Trojan Horse attacks: If Steve tricks Bob into copying data from table R into table R0, then the access control on table R doesn’t apply to the copy of the data in table R0.</data>
    </node>
    <node id="82">
      <data key="d0">Discretionary access control (DAC)</data>
      <data key="d1">Based on the concept of access privileges for giving users such privileges. SQL support DAC; most commercial DBMSs also support DAC.</data>
    </node>
    <node id="100">
      <data key="d0">The Lost Update Problem</data>
      <data key="d1">In the lost update problem, an update done to a data item by a transaction is lost as it is overwritten by the update done by another transaction. </data>
    </node>
    <node id="71">
      <data key="d0">Normalisation</data>
      <data key="d1">A common approach starts with a universal relation and applies decomposition to create new relations that satisfy certain normal forms (i.e. normalization).</data>
    </node>
    <node id="72">
      <data key="d0">Lossless Join</data>
      <data key="d1">To disallow the possibility of generating spurious tuples when a NATURAL JOIN operation is applied to the relations after decomposition.</data>
    </node>
    <node id="73">
      <data key="d0">Dependency preservation</data>
      <data key="d1">To ensure that each functional dependency can be inferred from functional dependencies after decomposition.</data>
    </node>
    <node id="74">
      <data key="d0">Boyce-Codd normal form (BCNF)</data>
      <data key="d1">Boyce-Codd Normal Form (BCNF) is one of the forms of database normalization. A database table is in BCNF if and only if there are no non-trivial functional dependencies of attributes on anything other than a superset of a candidate key.</data>
    </node>
    <node id="75">
      <data key="d0">Third normal form (3NF)</data>
      <data key="d1">The third normal form — or 3NF — is part of a set of concepts for database normalization that also includes first normal form (1NF) and second normal form (2NF).</data>
    </node>
    <node id="44">
      <data key="d0">EXISTS</data>
      <data key="d1">The EXISTS condition in SQL is used to check whether the result of a correlated nested query is empty (contains no tuples) or not. The result of EXISTS is a boolean value True or False. It can be used in a SELECT, UPDATE, INSERT or DELETE statement.</data>
    </node>
    <node id="16">
      <data key="d0">Attribute</data>
      <data key="d1">Attributes are used to describe the properties of information. In the relational model, they usually refer to atomic data.</data>
    </node>
    <node id="70">
      <data key="d0">Prime Attribute</data>
      <data key="d1">A prime attribute is an attribute occurring in a candidate key</data>
    </node>
    <node id="58">
      <data key="d0">Participation constraints</data>
      <data key="d1">Specifies whether the existence of any entity depends on its being related to another entity via the relationship type.</data>
    </node>
    <node id="49">
      <data key="d0">Total </data>
      <data key="d1">It specifies that each entity present in the entity set must mandatorily participate in at least one relationship instance of that relationship set,for this reason, it is also called as mandatory participation</data>
    </node>
    <node id="83">
      <data key="d0">GRANT</data>
      <data key="d1">GRANT gives privileges to users.</data>
    </node>
    <node id="36">
      <data key="d0">GROUP BY</data>
      <data key="d1">GROUP BY attribute list groups tuples for each value combination in the attribute list.</data>
    </node>
    <node id="37">
      <data key="d0">COUNT</data>
      <data key="d1">COUNT returns the total number of argument values</data>
    </node>
    <node id="38">
      <data key="d0">MIN</data>
      <data key="d1">MIN returns the minimum value of the arguments</data>
    </node>
    <node id="39">
      <data key="d0">HAVING</data>
      <data key="d1">We can use HAVING condition to add the condition on the groups.</data>
    </node>
    <node id="47">
      <data key="d0">Relationship</data>
      <data key="d1">Relationship types are represented as diamonds.</data>
    </node>
    <node id="63">
      <data key="d0">partial</data>
      <data key="d1">It specifies that each entity in the entity set may or may not participate in the relationship instance in that relationship set.</data>
    </node>
    <node id="86">
      <data key="d0">REVOKE</data>
      <data key="d1">REVOKE takes away privileges from users.</data>
    </node>
    <node id="87">
      <data key="d0">Specifying Privileges - Views</data>
      <data key="d1">Views provide an important mechanism for discretionary authorization.</data>
    </node>
    <node id="41">
      <data key="d0">Inner Join</data>
      <data key="d1">Inner Join is tuples are included in the result only if there is at least one matching in both relations.</data>
    </node>
    <node id="60">
      <data key="d0">One-To-Many</data>
      <data key="d1">A one-to-many relationship is where one occurrence in an entity relates to many occurrences in another entity.</data>
    </node>
    <node id="66">
      <data key="d0">Closure</data>
      <data key="d1">The set of all those attributes which can be functionally determined from an attribute set is called as the closure of that attribute set.
</data>
    </node>
    <node id="24">
      <data key="d0">CREATE TABLE</data>
      <data key="d1">The CREATE TABLE statement is used to create a new relation schema by specifying its name, its attributes and, optionally, its constraints.</data>
    </node>
    <node id="46">
      <data key="d0">Data structure</data>
      <data key="d1">The data structure is a data organization, management, and storage format that enables efficient access and modification. More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data.</data>
    </node>
    <node id="25">
      <data key="d0">DROP TABLE</data>
      <data key="d1">The DROP TABLE statement is used to remove an existing relation schema from a database schema.</data>
    </node>
    <node id="43">
      <data key="d0">Left Join</data>
      <data key="d1">A left join retains all rows of the left table regardless of whether there is a row that matches on the right table.</data>
    </node>
    <node id="65">
      <data key="d0">Trivial</data>
      <data key="d1">A FD is trivial if it can always be satisfied</data>
    </node>
    <node id="79">
      <data key="d0">Renaming</data>
      <data key="d1">Renaming is used to rename either the relation name or the attribute names, or both.</data>
    </node>
    <node id="18">
      <data key="d0">Superkey</data>
      <data key="d1">A superkey SK of R is a subset of attributes of R.</data>
    </node>
    <node id="61">
      <data key="d0">One-To-One</data>
      <data key="d1">One-to-one is where one occurrence of an entity relates to only one occurrence in another entity, eg if a man only marries one woman and a woman only marries one man, it is a one-to-one (1:1) relationship.</data>
    </node>
    <node id="78">
      <data key="d0">Selection</data>
      <data key="d1">Select operation chooses the subset of tuples from the relation that satisfies the given condition mentioned in the syntax of selection. The selection operation is also known as horizontal partitioning since it partitions the table or relation horizontally.
</data>
    </node>
    <node id="6">
      <data key="d0">Cartesian product</data>
      <data key="d1">The Cartesian product operation takes an ordered list of sets and returns a set of tuples.</data>
    </node>
    <node id="7">
      <data key="d0">Cardinality</data>
      <data key="d1">the cardinality of a set is a measure of the number of elements of the set.</data>
    </node>
    <node id="8">
      <data key="d0">Equality</data>
      <data key="d1">Set equality is the term that is used to indicate that two sets are equal.</data>
    </node>
    <node id="9">
      <data key="d0">union</data>
      <data key="d1">The union of two sets is a set containing all elements that are in A or in B (possibly both).</data>
    </node>
    <node id="10">
      <data key="d0">Intersection</data>
      <data key="d1">The intersection of two given sets is the set that contains all the elements that are common to both sets.</data>
    </node>
    <node id="11">
      <data key="d0">Difference</data>
      <data key="d1">The difference of two sets A and B is defined as the lists of all the elements that are in set A but that are not present in set B.</data>
    </node>
    <node id="13">
      <data key="d0">Tuple</data>
      <data key="d1">A tuple is an ordered list of n elements.</data>
    </node>
    <node id="17">
      <data key="d0">Relation</data>
      <data key="d1">A relation is a subset of a Cartesian product of sets.</data>
    </node>
    <edge source="54" target="53" />
    <edge source="53" target="56" />
    <edge source="53" target="48" />
    <edge source="56" target="50" />
    <edge source="59" target="57" />
    <edge source="57" target="60" />
    <edge source="57" target="47" />
    <edge source="96" target="94" />
    <edge source="94" target="93" />
    <edge source="15" target="14" />
    <edge source="26" target="22" />
    <edge source="89" target="81" />
    <edge source="81" target="86" />
    <edge source="81" target="87" />
    <edge source="20" target="14" />
    <edge source="40" target="32" />
    <edge source="64" target="67" />
    <edge source="64" target="68" />
    <edge source="64" target="69" />
    <edge source="64" target="14" />
    <edge source="99" target="95" />
    <edge source="42" target="33" />
    <edge source="33" target="32" />
    <edge source="33" target="41" />
    <edge source="102" target="93" />
    <edge source="93" target="92" />
    <edge source="93" target="101" />
    <edge source="91" target="97" />
    <edge source="91" target="92" />
    <edge source="91" target="94" />
    <edge source="91" target="95" />
    <edge source="98" target="95" />
    <edge source="55" target="53" />
    <edge source="80" target="89" />
    <edge source="80" target="81" />
    <edge source="80" target="85" />
    <edge source="50" target="57" />
    <edge source="88" target="80" />
    <edge source="88" target="81" />
    <edge source="103" target="93" />
    <edge source="19" target="14" />
    <edge source="21" target="32" />
    <edge source="21" target="28" />
    <edge source="21" target="22" />
    <edge source="21" target="23" />
    <edge source="27" target="14" />
    <edge source="28" target="35" />
    <edge source="28" target="29" />
    <edge source="28" target="30" />
    <edge source="28" target="31" />
    <edge source="34" target="14" />
    <edge source="52" target="19" />
    <edge source="52" target="34" />
    <edge source="52" target="27" />
    <edge source="77" target="76" />
    <edge source="45" target="56" />
    <edge source="45" target="48" />
    <edge source="45" target="51" />
    <edge source="45" target="53" />
    <edge source="84" target="81" />
    <edge source="12" target="4" />
    <edge source="4" target="6" />
    <edge source="4" target="7" />
    <edge source="4" target="8" />
    <edge source="4" target="9" />
    <edge source="4" target="10" />
    <edge source="4" target="11" />
    <edge source="4" target="13" />
    <edge source="4" target="17" />
    <edge source="90" target="82" />
    <edge source="82" target="81" />
    <edge source="82" target="86" />
    <edge source="82" target="87" />
    <edge source="100" target="95" />
    <edge source="71" target="72" />
    <edge source="71" target="73" />
    <edge source="71" target="74" />
    <edge source="71" target="75" />
    <edge source="44" target="32" />
    <edge source="16" target="70" />
    <edge source="16" target="14" />
    <edge source="58" target="49" />
    <edge source="58" target="50" />
    <edge source="58" target="47" />
    <edge source="58" target="63" />
    <edge source="83" target="82" />
    <edge source="36" target="32" />
    <edge source="36" target="37" />
    <edge source="36" target="38" />
    <edge source="36" target="39" />
    <edge source="66" target="16" />
    <edge source="24" target="22" />
    <edge source="46" target="56" />
    <edge source="25" target="22" />
    <edge source="43" target="33" />
    <edge source="65" target="64" />
    <edge source="79" target="76" />
    <edge source="18" target="52" />
    <edge source="18" target="14" />
    <edge source="61" target="57" />
    <edge source="78" target="76" />
  </graph>
</graphml>
